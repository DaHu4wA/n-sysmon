todo
----
* kurios
  * UUID.randomUUID() --> performance, blocking behavior

* architecture
  * resend data after failure --> just add to the queue again --> idempotence on the server

* server features
  * API for data retrieval
    * scalars, environment, traces
    * local and remote
  * simple web UI
    *
  * derived scalars as listeners on the event bus, e.g. 'requests per second', 'transactions per second' or 'GC frequency'
  * permission checks
    * collection with users / MD5 of password
    * admin flag, arrays of applications with read / write permissions
    * ?!?!?! --> Felix

* core
  * export? printer friendly presentation?

* presentation of active / open connections per pool: special treatment <active> / <open>

* load average from sun.misc.Unsafe --> Windows?!

* GC details: http://www.fasterj.com/articles/gcnotifs.shtml
  * special treatment for GC data?

* global measurements
  * /proc/diskstats

          Field 1 -- # of reads issued
          Field 2 -- # of reads merged, field 6 -- # of writes merged
          Field 3 -- # of sectors read
          Field 4 -- # of milliseconds spent reading
          Field 5 -- # of writes completed
          Field 7 -- # of sectors written
          Field 8 -- # of milliseconds spent writing
          Field 9 -- # of I/Os currently in progress
          Field 10 -- # of milliseconds spent doing I/Os
          Field 11 -- weighted # of milliseconds spent doing I/Os

          --> read aggregated values, calc 'current' values

  * /proc/stat

        These numbers identify the amount of time the CPU has spent performing different kinds of work. Time units are in USER_HZ or Jiffies (typically hundredths of a second).
         fields from left to right:

          user: normal processes executing in user mode
          nice: niced processes executing in user mode
          system: processes executing in kernel mode
          idle: twiddling thumbs
          iowait: waiting for I/O to complete
          irq: servicing interrupts
          softirq: servicing softirqs

          --> read aggregated values, calc 'current' values

  * /proc/net/dev

  * --> see code in 'meltdown'

  * how to differentiate between 'own' and 'foreign' load?!

  * Felix: cache hit / miss etc.

* cleanup
  * aggregation for built-in servlets: change to lock-free implementation

* acquire environment data
* limit measurement time for scalars and environment data

* logo in report servlets (?)

* offloading data sink
  * unique ids per measurement --> referencing (?)
  * support for 'correcting' real time clocks of systems
  * per hierarchy: Thread name, Host, PID
* 'push' (via UDP) vs. 'pull' (store locally, collect e.g. via servlet call --> provide servlet)

* trace GC (?)
* log asysmon overhead (?)

* extract a-base
  * partial order
  * mapWithDefault, mapWithDefaultValue
  * queue

AOP:
--> File I/O
--> Socket I/O

* instrumentation
  * 'correlation id' per thread, implicitly linked to other threads

* global measurements
  * JMX - tomcat, JVM, ...

* 'environment': OS version, RAM, processor, software version ...

* management server
  * rolling average for scalars
  * derived values - store them or calculate them on demand?
  * dashboard: configurable views
  * free JS graph library, update via server socket
  * communication *initiated* by applications, but management server sends *back* administrative commands (e.g. change measurement frequency, filter stuff, ...)
  * rapid changes in clock difference --> sound an alarm

* JS performance api


discuss
-------
* how to deal with data sources in app server --> outside application scope

documentation
-------------
* "globally disabled" by system property

* terminology
  * measurement: something ongoing --> something like a builder
  * data: immutable results of a finished measurement

* initialization
  * completely non-static
  * or static 'ASysMon.get()' --> AStaticSysMonConfig.get(), changes must be registered there before first access

* AMinMaxAvgServlet
  * load-on-startup = 1
  * security --> filter --> responsibility of the application
  * display
    * color coding / percentage: relative to immediate parent
    * #: average number of calls *per parent*

* database drill-up servlet
  * 'eventually consistent' --> trade-off to avoid global locking

* no top-level 'parallel' measurement

* Correlation ID etc.: as a 'context' of a measurement hierarchy (if present)
  * ASysMon.spawnNewCorrelation(...), ASysMon.joinCorrelation(...)
  * any time during a measurement --> knowledge of a correlation ID can come e.g. after parsing of a message, i.e. after JDBC or I/O
  * separate 'kind' and 'correlation id' to keep multiple

* shutdown
  * ASysMon.shutdown() shuts down all registered measurers and data sinks
  * if one of the servlets is registered, container shutdown shuts down ASysMon (unless otherwise configured --> AGlobalConfig.setImplicitlyShutDownWithServlet)
  * idempotent --> safe to shut down repeatedly

* server separation into modules: ...-war allows import of all code while providing your own web.xml (or bundling with your own application)
